<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Jun 6, 2013 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>RUGE User Guide</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
      <meta name="author" content="Brendan McCarthy" />
    <meta name="Date-Revision-yyyymmdd" content="20130606" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                RUGE- RUle GEnerator
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2013-06-06</span>
                  &nbsp;| <span id="projectVersion">Version: 0.0.1-SNAPSHOT</span>
                      </div>
            <div class="xright">                    <a href="http://www.apache.org/" class="externalLink" title="Furst">Furst</a>
            |
                        <a href="http://maven.apache.org/maven-1.x/" class="externalLink" title="Second">Second</a>
            |
                        <a href="http://maven.apache.org/" class="externalLink" title="Third">Third</a>
              
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                <h5>Overview</h5>
                  <ul>
                  <li class="none">
                          <a href="index.html" title="Introduction">Introduction</a>
            </li>
                  <li class="none">
            <strong>User Guide</strong>
          </li>
                  <li class="none">
                          <a href="faq.html" title="FAQ">FAQ</a>
            </li>
          </ul>
                       <h5>Configuration</h5>
                  <ul>
                  <li class="none">
                          <a href="download.html" title="Download+Setup">Download+Setup</a>
            </li>
                  <li class="none">
                          <a href="release-notes.html" title="Release Notes">Release Notes</a>
            </li>
          </ul>
                       <h5>Examples</h5>
                  <ul>
                  <li class="none">
                          <a href="examples.html" title="Examples">Examples</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                                            <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                      <li class="collapsed">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <ul><li><a href="#Prolog_First">Prolog First</a></li><li><a href="#Controlled_Randomization">Controlled Randomization</a><ul><li><a href="#Non-Deterministic_Choice">Non-Deterministic Choice</a></li><li><a href="#percent2">percent/2</a></li></ul></li><li><a href="#More_on_Generation">More on Generation</a><ul><li><a href="#Generation_Functions">Generation Functions</a></li></ul></li><li><a href="#Formatting_and_Directing_Output">Formatting and Directing Output</a><ul><li><a href="#Customizing_Structured_Terms">Customizing Structured Terms</a></li><li><a href="#Output_to_a_file">Output to a file</a></li></ul></li><li><a href="#Complex_Rules">Complex Rules</a><ul><li><a href="#Heterogenous_Output">Heterogenous Output</a></li><li><a href="#Nested_Rules">Nested Rules</a></li><li><a href="#Parameter_Passing">Parameter Passing</a></li><li><a href="#Buffering">Buffering</a></li></ul></li><li><a href="#Simulation_and_N-Stability">Simulation and N-Stability</a></li></ul><div class="section"><h2>Prolog First<a name="Prolog_First"></a></h2><p>RUGE provides a test-generation framework that extends core Prolog capabilities. Prolog is an excellent language for exploring a search space and generating elements from that search space. For example, this simple program uses the common generate-and-test idiom in Prolog:</p><div class="source"><pre>gen1 :-
        message(X),
        write(X),
        write(' '),
        fail.
gen1.

message(hello).
message(world).
</pre></div><p>Invoking gen1 produces this output (reminder: the 'yes' is printed at the end by Prolog when a call succeeds):</p><div class="source"><pre>| ?- gen1.
hello world 
yes
</pre></div></div><div class="section"><h2>Controlled Randomization<a name="Controlled_Randomization"></a></h2><p>Sometimes it useful to generate all possible combinations in this manner, but while Prolog is great for exploring all possibile valid combinations, most any non-trivial data/event model involves a vast and probably unlimited number of possible combinations. This is therefore not practical for general test generation. Nor is sufficient to generate the first n results from this set, as Prolog works in a depth first manner and will always produce the same set without ever getting to the rest. </p><div class="section"><h3>Non-Deterministic Choice<a name="Non-Deterministic_Choice"></a></h3><p>RUGE provides capabilities to introduce 'controlled' randomness into the exploration of the search space, thus making Prolog practical for general testing. For example, in the following we extend the program above with prefixes on the 'message' predicate:</p><div class="source"><pre>user:file_search_path(ruge,'$RUGE_HOME').

:- include(ruge(common)).

gen1 :-
        message(X),
        write(X),
        write(' '),
        fail.
gen1 :- nl.

75 pct message(hello).
25 pct message(world).
</pre></div><p>Now each invocation of message/1 will select only one clause, and 3 out of 4 times that will be the 'hello' clause. Each time gen1 is invoked, it will produce a different result, e.g.:</p><div class="source"><pre>| ?- gen1, gen1, gen1.
hello 
world 
hello 
yes
</pre></div><p>The 'pct' prefix may be applied to any predicate. It does not use Prolog's cut to ensure that only one clause gets selected, so if the one selected clause invokes other goals that build choicepoints, then those will still apply as normal on backtracking. It uses term_expansion, which is only visible if you do a listing to see the Prolog workspace, or during debugging.</p><p>The two header lines in the program above load the RUGE libraries. The illustrated approach assumes that RUGE_HOME has been set as an environment variable or on the prolog command line, e.g.</p><div class="source"><pre>sicstus -DRUGE_HOME=C:/some/where 
</pre></div><p>If you'd prefer to avoid this you could just hard-code the path in the header:</p><div class="source"><pre>user:file_search_path(ruge,'C:/some/where').

:- include(ruge(common)).
</pre></div><p>It's your choice. The RUGE_HOME approach simply allows multiple people to share the same copy of a file without having to pre-arrange a common library path. In any event, for readability remaining code examples will assume the header is provided. If you copy &amp; paste be sure to include the header of your choice. (Hint: if you forget the header, you'll see syntax errors because RUGE defines 'pct' as an operator which if not previously loaded will not be recognized by Prolog as valid syntax.)</p></div><div class="section"><h3>percent/2<a name="percent2"></a></h3><p>The 'pct' operator provides controlled randomization at the clause level, but RUGE also provides a percent/2 utility for controlled randomization at the goal level. The percent/2 predicate binds a variable to a random value as controlled by a supplied template expression. There are several variations to the syntax of the template expression, but here are a few examples:</p><table border="1" class="bodyTable"><caption>Template Expression example arguments for percent/2</caption><tr class="a"><td align="right">TEMPLATE EXPR</td><td align="left">RESULT</td></tr><tr class="b"><td align="right">[a,b,c]</td><td align="left">Random a, b, or c</td></tr><tr class="a"><td align="right">[a:80,b:10,c:10]</td><td align="left">80% of the time a, else b or c</td></tr><tr class="b"><td align="right">[a:80,b,c]</td><td align="left">Same as previous, the remaining 20% automatically allocated over b and c</td></tr><tr class="a"><td align="right">8..70</td><td align="left">An integer between 8 and 70</td></tr><tr class="b"><td align="right">8..avg(16)..70</td><td align="left">Same as above, but the average will be 16</td></tr><tr class="a"><td align="right">1-jan-2013..3-feb-2013</td><td align="left">A date range</td></tr><tr class="b"><td align="right">1-jan-2013..days(100)</td><td align="left">A date range with relative upper bound</td></tr><tr class="a"><td align="right">:my_pred</td><td align="left">A random value from user-defined my_pred/1</td></tr><tr class="b"><td align="right">set(2,[a,b,c])</td><td align="left">A list of length two, with unique elements a, b, or c</td></tr><tr class="a"><td align="right">set(1..3,[a,b,c])</td><td align="left">A random permutation of [a,b,c]</td></tr></table><p>The expression can be nested. For example, [1..3:80,999] will produce a number between 1 and 3 80% of the time, and 999 20% of the time. For a full description of these and other template subexpressions, see the documentation for percent/2.</p><p>Using percent/2, a variation on the example earlier might be this:</p><div class="source"><pre>gen1 :-
        percent(X,:message(_)),
        write(X),
        write(' '),
        fail.
gen1 :- nl.

message(hello).
message(world).
</pre></div><p>Which can be run like this:</p><div class="source"><pre>| ?- gen1, gen1, gen1.
world 
hello 
hello 
yes
</pre></div><p>Note that percent/2 by itself does <i>not</i> repeat on backtracking. It must be called anew every time a value is to be generated.</p></div></div><div class="section"><h2>More on Generation<a name="More_on_Generation"></a></h2><p>The preceding examples have included a user-defined generation loop. In practice, a number of other implementation considerations can sometimes be tedious to manage by hand. As an alternative, RUGE provides its own generation loop. All you have to do is provide the generation predicates.</p><div class="section"><h3>Generation Functions<a name="Generation_Functions"></a></h3><p>Remove the gen1 predicate from the previous examples, and add a few more clauses, so that the code is simply as follows:</p><div class="source"><pre>message(hello).
message(world).
message(out).
message(there).
</pre></div><p>The primary way to invoke the RUGE generation loop is to call gen/1 predicate, naming the targeted generation rule:</p><div class="source"><pre>| ?- gen(message).
[RUGE INFO] &quot;gen&quot; invoked from directory e:/dev/ruge/sample/src/main/prolog/
message(hello).
message(world).
message(out).
message(there).
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
</pre></div><p>A fixed number of answers can be requested. This assumes the target predicate can generate at least that many, so it is more a matter of asking for a maximum:</p><div class="source"><pre>  | ?- first(3,gen(message)).
[RUGE INFO] &quot;first&quot; invoked from directory e:/dev/ruge/sample/src/main/prolog/
message(hello).
message(world).
message(out).
[RUGE INFO] Execution summary: 3 lines in 0.001 seconds written to stdout
yes
</pre></div><p>Or to sort by a particular column (start counting at 1):</p><div class="source"><pre>| ?- csort(1,gen(message)).
[RUGE INFO] &quot;csort&quot; invoked from directory e:/dev/ruge/sample/src/main/prolog/
message(hello).
message(out).
message(there).
message(world).
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
</pre></div><p>Or to sort then select a fixed quantity:</p><div class="source"><pre>| ?- first(3,csort(1,gen(message))).
[RUGE INFO] &quot;first&quot; invoked from directory e:/dev/ruge/sample/src/main/prolog/
message(hello).
message(out).
message(there).
[RUGE INFO] Execution summary: 3 lines in 0.001 seconds written to stdout
yes
</pre></div><p>There are additional predicates available, see the descriptions in evgen.pl. Some are described in the remaining sections of this document.</p></div></div><div class="section"><h2>Formatting and Directing Output<a name="Formatting_and_Directing_Output"></a></h2><p>The default output format is simply the Prolog terms themselves, but often an alternative format is desired that can be consumed by non-Prolog applications. Currently the alternatives are csv (comma-seperate-value) or xml, e.g.:</p><div class="source"><pre>| ?- store(csv,gen(message)).
[RUGE INFO] &quot;store&quot; invoked from directory e:/dev/ruge/sample/src/main/prolog/
message,hello
message,world
message,out
message,there
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
</pre></div><div class="section"><h3>Customizing Structured Terms<a name="Customizing_Structured_Terms"></a></h3><p>Sometimes it is useful to work with complex terms that must be formatted a certain way. An example is email. The following example adds an email/2 argument to message, and then defines how to format it using expose_term/3. RUGE discovers the latter when formatting and uses it to construct arguments to Prolog's built-in format/2:</p><div class="source"><pre>message(hello,email(groucho,yahoo)).
message(world,email(harpo,gmail)).
message(out,email(chico,hotmail)).
message(there,email(zeppo,aol)).

expose_term(email(N,Domain),&quot;~a@~a.com&quot;,[N,Domain]).
</pre></div><p>The formatting now appears as follows:</p><div class="source"><pre>| ?- store(csv,gen(message)).
[RUGE INFO] &quot;store&quot; invoked from directory e:/dev/ruge/sample/src/main/prolog/
message,hello,groucho@yahoo.com
message,world,harpo@gmail.com
message,out,chico@hotmail.com
message,there,zeppo@aol.com
[RUGE INFO] Execution summary: 4 lines in 0.002 seconds written to stdout
yes
</pre></div></div><div class="section"><h3>Output to a file<a name="Output_to_a_file"></a></h3><p>The use of 'store' for this predicate name serves double purpose. The output can be directed to a file as follows:</p><div class="source"><pre>| ?- store(file(my_messages,csv),gen(message)).
[RUGE INFO] &quot;store&quot; invoked from directory e:/dev/ruge/sample/src/main/prolog/
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to e:/dev/ruge/sample/src/main/prolog/generated/my_messages.csv
yes
</pre></div><p>As indicated, the output is in the file my_messages.csv file. It is put in a special directory named 'generated' in order to avoid confliciting with any other files you might have in your current directory. That directory is in turn relative to the current working directory of the Prolog interpreter, which is by default wherever you start up the interpreter. In order to avoid confusion, the INFO messages provide explicit directory information about what directory you invoke commands in and where output ends up.</p><p>A common need when using store/2 or similar predicate that aggregates its nested results is to sequence multiple rules within it. For example, it might be desirable to output initialization events before body events:</p><div class="source"><pre>:- include(ruge(common)).

intro(hello).
intro(world).

body(out).
body(there).
</pre></div><p>Which can be run as in these examples, directly or within store/2:</p><div class="source"><pre>| ?- seq(gen(intro),gen(body)).
[RUGE INFO] &quot;seq&quot; invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
intro(hello).
intro(world).
body(out).
body(there).
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
| ?- store(csv,seq(gen(intro),gen(body))).
[RUGE INFO] &quot;store&quot; invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
intro,hello
intro,world
body,out
body,there
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
</pre></div></div></div><div class="section"><h2>Complex Rules<a name="Complex_Rules"></a></h2><p>In our example so far, the name of the predicate has matched the desired output item exactly: the predicate <i>message</i> has produced the term <i>message</i>. RUGE provides A more general rule syntax that allows the predicate name to be distinct from the generated term. Extending the previous example, provdiding the prefix 'say::' makes that ('say') the predicate name while still producing the same <i>message</i> construct:</p><div class="source"><pre>say::message(hello,email(groucho,yahoo)).
say::message(world,email(harpo,gmail)).
say::message(out,email(chico,hotmail)).
say::message(there,email(zeppo,aol)).

expose_term(email(N,Domain),&quot;~a@~a.com&quot;,[N,Domain]).
</pre></div><div class="section"><h3>Heterogenous Output<a name="Heterogenous_Output"></a></h3><p>One reason why you might want to do this is to provide different output constructs, e.g.:</p><div class="source"><pre>say::message(hello,email(groucho,yahoo)).
say::update(world,email(harpo,gmail)).
say::post(out,email(chico,hotmail)).
say::communique(there,email(zeppo,aol)).

expose_term(email(N,Domain),&quot;~a@~a.com&quot;,[N,Domain]).
</pre></div><p>Which generates all the variations:</p><div class="source"><pre>| ?- gen(say).
[RUGE INFO] &quot;gen&quot; invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message(hello,email(groucho,yahoo)).
update(world,email(harpo,gmail)).
post(out,email(chico,hotmail)).
communique(there,email(zeppo,aol)).
[RUGE INFO] Execution summary: 4 lines in 0.002 seconds written to stdout
yes
</pre></div><p>Combined with the pct opeprator described earlier, we can randomly (with skew) select just one rule:</p><div class="source"><pre>10 pct say::message(hello,email(groucho,yahoo)).
10 pct say::update(world,email(harpo,gmail)).
70 pct say::post(out,email(chico,hotmail)).
10 pct say::communique(there,email(zeppo,aol)).

expose_term(email(N,Domain),&quot;~a@~a.com&quot;,[N,Domain]).
</pre></div><p>Which when run will (usually) select the third clause:</p><div class="source"><pre>| ?- gen(say).
[RUGE INFO] &quot;gen&quot; invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
post(out,email(chico,hotmail)).
[RUGE INFO] Execution summary: 1 line in 0.0 seconds written to stdout
yes
</pre></div></div><div class="section"><h3>Nested Rules<a name="Nested_Rules"></a></h3><p>Alternatively, the pct/2 constructs and generation rules might be separated. This leads to another reason For using the <i>::</i> construct, that the generated term might be a variable that is bound lower-down in the program. This example produces the exact results as the previous one:</p><div class="source"><pre>say::R :- valid_say(R).

10 pct valid_say(message(hello,email(groucho,yahoo))).
10 pct valid_say(update(world,email(harpo,gmail))).
70 pct valid_say(post(out,email(chico,hotmail))).
10 pct valid_say(communique(there,email(zeppo,aol))).

expose_term(email(N,Domain),&quot;~a@~a.com&quot;,[N,Domain]).
</pre></div></div><div class="section"><h3>Parameter Passing<a name="Parameter_Passing"></a></h3><p>Another reason for this syntax is to allow the passing of values that are not directly part of the generated term. For example, another way to control the generated quantity is to pass the value into the rule:</p><div class="source"><pre>say(N)::R :-
        between(1,N,_),
        valid_say(R).

valid_say(message(Word,email(User,Domain))) :-
        percent(Word,[hello,world,out,there,you]),
        percent(User,[groucho,harpo,chico,zeppo]),
        percent(Domain,[yahoo,gmail,hotmail,aol]).

expose_term(email(N,Domain),&quot;~a@~a.com&quot;,[N,Domain]).
</pre></div><p>The value for N can be passed in like this:</p><div class="source"><pre>| ?- gen(say(3)).
[RUGE INFO] &quot;gen&quot; invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message(hello,email(harpo,gmail)).
message(you,email(chico,aol)).
message(you,email(groucho,hotmail)).
[RUGE INFO] Execution summary: 3 lines in 0.001 seconds written to stdout
yes
</pre></div><p>It should be noted that -- useful for debugging -- you can still invoke these predicates directly from Prolog without going through RUGE:</p><div class="source"><pre>| ?- say(2)::R.
R = message(there,email(groucho,aol)) ? ;
R = message(out,email(zeppo,gmail)) ? ;
no
</pre></div></div><div class="section"><h3>Buffering<a name="Buffering"></a></h3><p>A final reason to use the '::' construct on rules is when buffering. RUGE output is not by default buffered, which makes for very fast output generation of large rulesets. Sometimes however it is desirable to buffer the data in memory to allow rules to reference previously-generated entries. The following program does this:</p><div class="source"><pre>:- dynamic message/2.

say::message(X,Count1) :-
        between(1,9,_),
        percent(X,[blue,green,red]),
        findall(X,message(X,_),Cs),
        length(Cs,Count),
        Count1 is Count+1.
</pre></div><p>Run without than with buffering, observe the effect:</p><div class="source"><pre>| ?- gen(say).
[RUGE INFO] &quot;gen&quot; invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
message(green,1).
message(green,1).
message(red,1).
message(blue,1).
message(blue,1).
message(blue,1).
message(blue,1).
message(red,1).
message(red,1).
[RUGE INFO] Execution summary: 9 lines in 0.003 seconds written to stdout
yes
| ?- buffer(gen(say)).
[RUGE INFO] &quot;buffer&quot; invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
message(blue,1).
message(red,1).
message(blue,2).
message(blue,3).
message(green,1).
message(red,2).
message(blue,4).
message(red,3).
message(red,4).
[RUGE INFO] Execution summary: 9 lines in 0.002 seconds written to stdout
yes
</pre></div></div></div><div class="section"><h2>Simulation and N-Stability<a name="Simulation_and_N-Stability"></a></h2><p>TBD...</p></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2013
                        <a href="http://devclear.com/ruge">DevClear</a>.
            All Rights Reserved.      
        
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>