            ------
            RUGE User Guide
            ------
            Brendan McCarthy
            ------
            6 June 2013
            ------             
  
Prolog First

  RUGE provides a test-generation framework that extends core Prolog capabilities. Prolog is an excellent language for
exploring a search space and generating elements from that search space. 
For example, this simple program uses the common generate-and-test idiom in Prolog:

+------------------------------------------+
gen1 :-
	message(X),
	write(X),
	write(' '),
	fail.
gen1.

message(hello).
message(world).
+------------------------------------------+

  Invoking gen1 produces this output (reminder: the 'yes' is printed at the end by Prolog when a call succeeds):
  
+------------------------------------------+
| ?- gen1.
hello world 
yes
+------------------------------------------+

  Sometimes it useful to generate all possible combinations in this manner, but while Prolog is great for exploring all 
possibile valid combinations, most 
any non-trivial data/event model involves a vast and probably unlimited number of possible combinations. This is therefore
not practical for general 
test generation. Nor is sufficient to generate the first n results from this set, as Prolog works in a depth first manner and will always 
produce the same set without ever getting to the rest. 

Controlled Randomization

  RUGE provides capabilities to introduce 'controlled' randomness into the exploration of the search space, thus making Prolog practical for
general testing. For example, in the following we extend the program above with prefixes on the 'message' predicate:

+------------------------------------------+
user:file_search_path(ruge,'$RUGE_HOME').

:- include(ruge(common)).

gen1 :-
	message(X),
	write(X),
	write(' '),
	fail.
gen1 :- nl.

75 pct message(hello).
25 pct message(world).
+------------------------------------------+

  Now each invocation of message/1 will select only one clause, and 3 out of 4 times that will be the 'hello' clause. Each time
gen1 is invoked, it will produce a different result, e.g.:
 
+------------------------------------------+
| ?- gen1, gen1, gen1.
hello 
world 
hello 
yes
+------------------------------------------+

  The 'pct' prefix may be applied to any predicate. It does not use Prolog's cut to ensure that only one clause gets selected, 
so if the one selected clause invokes other goals that build choicepoints, then those will still apply as normal on backtracking.
It uses term_expansion, which is only visible if you do a listing to see the Prolog workspace, or during debugging.

  The two header lines in the program above load the RUGE libraries. The illustrated approach assumes that RUGE_HOME has been
set as an environment variable or on the prolog command line, e.g.

+------------------------------------------+
sicstus -DRUGE_HOME=C:/some/where 
+------------------------------------------+

  If you'd prefer to avoid this you could just hard-code the path in the header:
  
+------------------------------------------+
user:file_search_path(ruge,'C:/some/where').

:- include(ruge(common)).
+------------------------------------------+

  It's your choice. The RUGE_HOME approach simply allows multiple people to share the same copy of a file without having
to pre-arrange a common library path. In any event, for readability remaining code examples will assume the header is provided.
If you copy & paste be sure to include the header of your choice. (Hint: if you forget the header, you'll see syntax errors
because RUGE defines 'pct' as an operator which if not previously loaded will not be recognized by Prolog as valid syntax.)

  The 'pct' operator provides controlled randomization at the clause level, but RUGE also provides a percent/2 utility for
controlled randomization at the goal level. The percent/2 predicate binds a variable to a random value as controlled by a
supplied template expression. There are several variations to the syntax of the template expression, but here are a few
examples:

*----------:--------+
| TEMPLATE EXPR | RESULT |
*----------:--------+
| [a,b,c] | Random a, b, or c     |
*----------:--------+
| [a:80,b:10,c:10] | 80% of the time a, else b or c |
*----------:--------+
| [a:80,b,c] | Same as previous, the remaining 20% automatically allocated over b and c |
*----------:--------+
| 8..70 | An integer between 8 and 70 |
*----------:--------+
| 8..avg(16)..70| Same as above, but the average will be 16 |
*----------:--------+
| 1-jan-2013..3-feb-2013| A date range |
*----------:--------+
| 1-jan-2013..days(100)| A date range with relative upper bound|
*----------:--------+
| :my_pred | A random value from user-defined my_pred/1 |
*----------:--------+
| set(2,[a,b,c]) | A list of length two, with unique elements a, b, or c|
*----------:--------+
| set(1..3,[a,b,c]) | A random permutation of [a,b,c] |
*----------:--------+
Template Expression example arguments for percent/2

  For a full description of combinations, see the documentation for percent/2.
  
  Using percent/2, a variation on the example earlier might be this:
  
+------------------------------------------+
gen1 :-
	percent(X,:message(_)),
	write(X),
	write(' '),
	fail.
gen1 :- nl.

message(hello).
message(world).
+------------------------------------------+

  Which can be run like this:

+------------------------------------------+
| ?- gen1, gen1, gen1.
world 
hello 
hello 
yes
+------------------------------------------+  

  Note that percent/2 by itself does <not> repeat on backtracking. It must be called anew every time a value is to be generated.
  

More on Generation

  The preceding examples have included a user-defined generation loop. In practice, a number of other implementation considerations 
can sometimes be tedious to manage by hand. As an alternative, RUGE provides its own generation loop. All you have
to do is provide the generation predicates.

  Remove the gen1 predicate from the previous examples, and add a few more clauses, so that the code is simply as follows:

+------------------------------------------+
message(hello).
message(world).
message(out).
message(there).
+------------------------------------------+

  The primary way to invoke the RUGE generation loop is to call gen/1 predicate, naming the targeted generation rule:

+------------------------------------------+
| ?- gen(message).
[RUGE INFO] "gen" invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message(hello).
message(world).
message(out).
message(there).
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+

  A fixed number of answers can be requested. This assumes the target predicate
can generate at least that many, so it is more a matter of asking for a maximum:
  
+------------------------------------------+  
  | ?- first(3,gen(message)).
[RUGE INFO] "first" invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message(hello).
message(world).
message(out).
[RUGE INFO] Execution summary: 3 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  


  Or to sort by a particular column (start counting at 1):

+------------------------------------------+  
| ?- csort(1,gen(message)).
[RUGE INFO] "csort" invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message(hello).
message(out).
message(there).
message(world).
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  

  Or to sort then select a fixed quantity:

+------------------------------------------+  
| ?- first(3,csort(1,gen(message))).
[RUGE INFO] "first" invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message(hello).
message(out).
message(there).
[RUGE INFO] Execution summary: 3 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  


Formatting

  The default output format is simply the Prolog terms themselves, but often an alternative format is desired that 
can be consumed by non-Prolog applications. Currently the alternatives are csv (comma-seperate-value) or xml, e.g.:

+------------------------------------------+  
| ?- store(csv,gen(message)).
[RUGE INFO] "store" invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message,hello
message,world
message,out
message,there
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  

  Sometimes it is useful to work with complex terms that must be formatted a certain way. An example is email.
The following example adds an email/2 argument to message, and then defines how to format it using expose_term/3.
RUGE discovers the latter when formatting and uses it to construct arguments to Prolog's built-in format/2:

+------------------------------------------+  
message(hello,email(groucho,yahoo)).
message(world,email(harpo,gmail)).
message(out,email(chico,hotmail)).
message(there,email(zeppo,aol)).

expose_term(email(N,Domain),"~a@~a.com",[N,Domain]).
+------------------------------------------+  

  The formatting now appears as follows:

+------------------------------------------+  
| ?- store(csv,gen(message)).
[RUGE INFO] "store" invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message,hello,groucho@yahoo.com
message,world,harpo@gmail.com
message,out,chico@hotmail.com
message,there,zeppo@aol.com
[RUGE INFO] Execution summary: 4 lines in 0.002 seconds written to stdout
yes
+------------------------------------------+  



File Output






 
 