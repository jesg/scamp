            ------
            RUGE User Guide
            ------
            Brendan McCarthy
            ------
            6 June 2013
            ------             
  
Prolog First

  RUGE provides a test-generation framework that extends core Prolog capabilities. Prolog is an excellent language for
exploring a search space and generating elements from that search space. 
For example, this simple program uses the common generate-and-test idiom in Prolog:

+------------------------------------------+
gen1 :-
	message(X),
	write(X),
	write(' '),
	fail.
gen1.

message(hello).
message(world).
+------------------------------------------+

  Invoking gen1 produces this output (reminder: the 'yes' is printed at the end by Prolog when a call succeeds):
  
+------------------------------------------+
| ?- gen1.
hello world 
yes
+------------------------------------------+

  Sometimes it useful to generate all possible combinations in this manner, but while Prolog is great for exploring all 
possibile valid combinations, most 
any non-trivial data/event model involves a vast and probably unlimited number of possible combinations. This is therefore
not practical for general 
test generation. Nor is sufficient to generate the first n results from this set, as Prolog works in a depth first manner and will always 
produce the same set without ever getting to the rest. 

Controlled Randomization

  RUGE provides capabilities to introduce 'controlled' randomness into the exploration of the search space, thus making Prolog practical for
general testing. For example, in the following we extend the program above with prefixes on the 'message' predicate:

+------------------------------------------+
user:file_search_path(ruge,'$RUGE_HOME').

:- include(ruge(common)).

gen1 :-
	message(X),
	write(X),
	write(' '),
	fail.
gen1 :- nl.

75 pct message(hello).
25 pct message(world).
+------------------------------------------+

  Now each invocation of message/1 will select only one clause, and 3 out of 4 times that will be the 'hello' clause. Each time
gen1 is invoked, it will produce a different result, e.g.:
 
+------------------------------------------+
| ?- gen1, gen1, gen1.
hello 
world 
hello 
yes
+------------------------------------------+

  The 'pct' prefix may be applied to any predicate. It does not use Prolog's cut to ensure that only one clause gets selected, 
so if the one selected clause invokes other goals that build choicepoints, then those will still apply as normal on backtracking.
It uses term_expansion, which is only visible if you do a listing to see the Prolog workspace, or during debugging.

  The two header lines in the program above load the RUGE libraries. The illustrated approach assumes that RUGE_HOME has been
set as an environment variable or on the prolog command line, e.g.

+------------------------------------------+
sicstus -DRUGE_HOME=C:/some/where 
+------------------------------------------+

  If you'd prefer to avoid this you could just hard-code the path in the header:
  
+------------------------------------------+
user:file_search_path(ruge,'C:/some/where').

:- include(ruge(common)).
+------------------------------------------+

  It's your choice. The RUGE_HOME approach simply allows multiple people to share the same copy of a file without having
to pre-arrange a common library path. In any event, for readability remaining code examples will assume the header is provided.
If you copy & paste be sure to include the header of your choice. (Hint: if you forget the header, you'll see syntax errors
because RUGE defines 'pct' as an operator which if not previously loaded will not be recognized by Prolog as valid syntax.)

  The 'pct' operator provides controlled randomization at the clause level, but RUGE also provides a percent/2 utility for
controlled randomization at the goal level. The percent/2 predicate binds a variable to a random value as controlled by a
supplied template expression. There are several variations to the syntax of the template expression, but here are a few
examples:

*----------:--------+
| TEMPLATE EXPR | RESULT |
*----------:--------+
| [a,b,c] | Random a, b, or c     |
*----------:--------+
| [a:80,b:10,c:10] | 80% of the time a, else b or c |
*----------:--------+
| [a:80,b,c] | Same as previous, the remaining 20% automatically allocated over b and c |
*----------:--------+
| 8..70 | An integer between 8 and 70 |
*----------:--------+
| 8..avg(16)..70| Same as above, but the average will be 16 |
*----------:--------+
| 1-jan-2013..3-feb-2013| A date range |
*----------:--------+
| 1-jan-2013..days(100)| A date range with relative upper bound|
*----------:--------+
| :my_pred | A random value from user-defined my_pred/1 |
*----------:--------+
| set(2,[a,b,c]) | A list of length two, with unique elements a, b, or c|
*----------:--------+
| set(1..3,[a,b,c]) | A random permutation of [a,b,c] |
*----------:--------+
Template Expression example arguments for percent/2

  For a full description of combinations, see the documentation for percent/2.
  
  Using percent/2, a variation on the example earlier might be this:
  
+------------------------------------------+
gen1 :-
	percent(X,:message(_)),
	write(X),
	write(' '),
	fail.
gen1 :- nl.

message(hello).
message(world).
+------------------------------------------+

  Which can be run like this:

+------------------------------------------+
| ?- gen1, gen1, gen1.
world 
hello 
hello 
yes
+------------------------------------------+  

  Note that percent/2 by itself does <not> repeat on backtracking. It must be called anew every time a value is to be generated.
  
Formatting





 
 