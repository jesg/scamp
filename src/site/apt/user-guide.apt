            ------
            RUGE User Guide
            ------
            Brendan McCarthy
            ------
            6 June 2013
            ------             
  

%{toc}

  
Prolog First

  RUGE provides a test-generation framework that extends core Prolog capabilities. Prolog is an excellent language for
exploring a search space and generating elements from that search space. 
For example, this simple program uses the common generate-and-test idiom in Prolog:

+------------------------------------------+
gen1 :-
	message(X),
	write(X),
	write(' '),
	fail.
gen1.

message(hello).
message(world).
+------------------------------------------+

  Invoking gen1 produces this output (reminder: the 'yes' is printed at the end by Prolog when a call succeeds):
  
+------------------------------------------+
| ?- gen1.
hello world 
yes
+------------------------------------------+

Controlled Randomization

  Sometimes it useful to generate all possible combinations in this manner, but while Prolog is great for exploring all 
possibile valid combinations, most 
any non-trivial data/event model involves a vast and probably unlimited number of possible combinations. This is therefore
not practical for general 
test generation. Nor is sufficient to generate the first n results from this set, as Prolog works in a depth first manner and will always 
produce the same set without ever getting to the rest. 

* Non-Deterministic Choice

  RUGE provides capabilities to introduce 'controlled' randomness into the exploration of the search space, thus making Prolog practical for
general testing. For example, in the following we extend the program above with prefixes on the 'message' predicate:

+------------------------------------------+
user:file_search_path(ruge,'$RUGE_HOME').

:- include(ruge(common)).

gen1 :-
	message(X),
	write(X),
	write(' '),
	fail.
gen1 :- nl.

75 pct message(hello).
25 pct message(world).
+------------------------------------------+

  Now each invocation of message/1 will select only one clause, and 3 out of 4 times that will be the 'hello' clause. Each time
gen1 is invoked, it will produce a different result, e.g.:
 
+------------------------------------------+
| ?- gen1, gen1, gen1.
hello 
world 
hello 
yes
+------------------------------------------+

  The 'pct' prefix may be applied to any predicate. It does not use Prolog's cut to ensure that only one clause gets selected, 
so if the one selected clause invokes other goals that build choicepoints, then those will still apply as normal on backtracking.
It uses term_expansion, which is only visible if you do a listing to see the Prolog workspace, or during debugging.

  The two header lines in the program above load the RUGE libraries. The illustrated approach assumes that RUGE_HOME has been
set as an environment variable or on the prolog command line, e.g.

+------------------------------------------+
sicstus -DRUGE_HOME=C:/some/where 
+------------------------------------------+

  If you'd prefer to avoid this you could just hard-code the path in the header:
  
+------------------------------------------+
user:file_search_path(ruge,'C:/some/where').

:- include(ruge(common)).
+------------------------------------------+

  It's your choice. The RUGE_HOME approach simply allows multiple people to share the same copy of a file without having
to pre-arrange a common library path. In any event, for readability remaining code examples will assume the header is provided.
If you copy & paste be sure to include the header of your choice. (Hint: if you forget the header, you'll see syntax errors
because RUGE defines 'pct' as an operator which if not previously loaded will not be recognized by Prolog as valid syntax.)

* percent/2

  The 'pct' operator provides controlled randomization at the clause level, but RUGE also provides a percent/2 utility for
controlled randomization at the goal level. The percent/2 predicate binds a variable to a random value as controlled by a
supplied template expression. There are several variations to the syntax of the template expression, but here are a few
examples:

*----------:--------+
| TEMPLATE EXPR | RESULT |
*----------:--------+
| [a,b,c] | Random a, b, or c     |
*----------:--------+
| [a:80,b:10,c:10] | 80% of the time a, else b or c |
*----------:--------+
| [a:80,b,c] | Same as previous, the remaining 20% automatically allocated over b and c |
*----------:--------+
| 8..70 | An integer between 8 and 70 |
*----------:--------+
| 8..avg(16)..70| Same as above, but the average will be 16 |
*----------:--------+
| 1-jan-2013..3-feb-2013| A date range |
*----------:--------+
| 1-jan-2013..days(100)| A date range with relative upper bound|
*----------:--------+
| :my_pred | A random value from user-defined my_pred/1 |
*----------:--------+
| set(2,[a,b,c]) | A list of length two, with unique elements a, b, or c|
*----------:--------+
| set(1..3,[a,b,c]) | A random permutation of [a,b,c] |
*----------:--------+
Template Expression example arguments for percent/2

  The expression can be nested. For example, [1..3:80,999] will produce a number between 1 and 3 80% of the time, 
and 999 20% of the time. For a full description of these and other template subexpressions, see the documentation for percent/2.
  
  Using percent/2, a variation on the example earlier might be this:
  
+------------------------------------------+
gen1 :-
	percent(X,:message(_)),
	write(X),
	write(' '),
	fail.
gen1 :- nl.

message(hello).
message(world).
+------------------------------------------+

  Which can be run like this:

+------------------------------------------+
| ?- gen1, gen1, gen1.
world 
hello 
hello 
yes
+------------------------------------------+  

  Note that percent/2 by itself does <not> repeat on backtracking. It must be called anew every time a value is to be generated.
  

More on Generation

  The preceding examples have included a user-defined generation loop. In practice, a number of other implementation considerations 
can sometimes be tedious to manage by hand. As an alternative, RUGE provides its own generation loop. All you have
to do is provide the generation predicates.

* Generation Functions

  Remove the gen1 predicate from the previous examples, and add a few more clauses, so that the code is simply as follows:

+------------------------------------------+
message(hello).
message(world).
message(out).
message(there).
+------------------------------------------+

  The primary way to invoke the RUGE generation loop is to call gen/1 predicate, naming the targeted generation rule:

+------------------------------------------+
| ?- gen(message).
[RUGE INFO] "gen" invoked from directory e:/dev/ruge/sample/src/main/prolog/
message(hello).
message(world).
message(out).
message(there).
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+

  A fixed number of answers can be requested. This assumes the target predicate
can generate at least that many, so it is more a matter of asking for a maximum:
  
+------------------------------------------+  
  | ?- first(3,gen(message)).
[RUGE INFO] "first" invoked from directory e:/dev/ruge/sample/src/main/prolog/
message(hello).
message(world).
message(out).
[RUGE INFO] Execution summary: 3 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  

  Or to sort by a particular column (start counting at 1):

+------------------------------------------+  
| ?- csort(1,gen(message)).
[RUGE INFO] "csort" invoked from directory e:/dev/ruge/sample/src/main/prolog/
message(hello).
message(out).
message(there).
message(world).
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  

  Or to sort then select a fixed quantity:

+------------------------------------------+  
| ?- first(3,csort(1,gen(message))).
[RUGE INFO] "first" invoked from directory e:/dev/ruge/sample/src/main/prolog/
message(hello).
message(out).
message(there).
[RUGE INFO] Execution summary: 3 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  

  There are additional predicates available, see the descriptions in evgen.pl. Some are described in the remaining
sections of this document.


Formatting and Directing Output

  The default output format is simply the Prolog terms themselves, but often an alternative format is desired that 
can be consumed by non-Prolog applications. Currently the alternatives are csv (comma-seperate-value) or xml, e.g.:

+------------------------------------------+  
| ?- store(csv,gen(message)).
[RUGE INFO] "store" invoked from directory e:/dev/ruge/sample/src/main/prolog/
message,hello
message,world
message,out
message,there
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  

* Customizing Structured Terms

  Sometimes it is useful to work with complex terms that must be formatted a certain way. An example is email.
The following example adds an email/2 argument to message, and then defines how to format it using expose_term/3.
RUGE discovers the latter when formatting and uses it to construct arguments to Prolog's built-in format/2:

+------------------------------------------+  
message(hello,email(groucho,yahoo)).
message(world,email(harpo,gmail)).
message(out,email(chico,hotmail)).
message(there,email(zeppo,aol)).

expose_term(email(N,Domain),"~a@~a.com",[N,Domain]).
+------------------------------------------+  

  The formatting now appears as follows:

+------------------------------------------+  
| ?- store(csv,gen(message)).
[RUGE INFO] "store" invoked from directory e:/dev/ruge/sample/src/main/prolog/
message,hello,groucho@yahoo.com
message,world,harpo@gmail.com
message,out,chico@hotmail.com
message,there,zeppo@aol.com
[RUGE INFO] Execution summary: 4 lines in 0.002 seconds written to stdout
yes
+------------------------------------------+  

* Output to a file

  The use of 'store' for this predicate name serves double purpose. The output can be directed to a file as follows:
  
+------------------------------------------+  
| ?- store(file(my_messages,csv),gen(message)).
[RUGE INFO] "store" invoked from directory e:/dev/ruge/sample/src/main/prolog/
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to e:/dev/ruge/sample/src/main/prolog/generated/my_messages.csv
yes
+------------------------------------------+    

  As indicated, the output is in the file my_messages.csv file. It is put in a special directory named 'generated' in order to
avoid confliciting with any other files you might have in your current directory. That directory is in turn relative to the
current working directory of the Prolog interpreter, which is by default wherever you start up the interpreter. In order to
avoid confusion, the INFO messages provide explicit directory information about what directory you invoke commands in and
where output ends up.

  A common need when using store/2 or similar predicate that aggregates its nested results is to sequence multiple rules within it.
For example, it might be desirable to output initialization events before body events:

+------------------------------------------+  
:- include(ruge(common)).

intro(hello).
intro(world).

body(out).
body(there).
+------------------------------------------+    

  Which can be run as in these examples, directly or within store/2:

+------------------------------------------+  
| ?- seq(gen(intro),gen(body)).
[RUGE INFO] "seq" invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
intro(hello).
intro(world).
body(out).
body(there).
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
| ?- store(csv,seq(gen(intro),gen(body))).
[RUGE INFO] "store" invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
intro,hello
intro,world
body,out
body,there
[RUGE INFO] Execution summary: 4 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  

Complex Rules

  In our example so far, the name of the predicate has matched the desired output item exactly: the predicate <message>
has produced the term <message>. RUGE provides A more general rule syntax that allows the predicate name to be distinct 
from the generated term. Extending the previous example, provdiding the prefix 'say::' makes that ('say') the predicate
name while still producing the same <message> construct:

+------------------------------------------+ 
say::message(hello,email(groucho,yahoo)).
say::message(world,email(harpo,gmail)).
say::message(out,email(chico,hotmail)).
say::message(there,email(zeppo,aol)).

expose_term(email(N,Domain),"~a@~a.com",[N,Domain]).
+------------------------------------------+  

* Heterogenous Output

  One reason why you might want to do this is to provide different output constructs, e.g.:

+------------------------------------------+  
say::message(hello,email(groucho,yahoo)).
say::update(world,email(harpo,gmail)).
say::post(out,email(chico,hotmail)).
say::communique(there,email(zeppo,aol)).

expose_term(email(N,Domain),"~a@~a.com",[N,Domain]).
+------------------------------------------+  

  Which generates all the variations:

+------------------------------------------+  
| ?- gen(say).
[RUGE INFO] "gen" invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message(hello,email(groucho,yahoo)).
update(world,email(harpo,gmail)).
post(out,email(chico,hotmail)).
communique(there,email(zeppo,aol)).
[RUGE INFO] Execution summary: 4 lines in 0.002 seconds written to stdout
yes
+------------------------------------------+  

  Combined with the pct opeprator described earlier, we can randomly (with skew) select just
one rule:

+------------------------------------------+  
10 pct say::message(hello,email(groucho,yahoo)).
10 pct say::update(world,email(harpo,gmail)).
70 pct say::post(out,email(chico,hotmail)).
10 pct say::communique(there,email(zeppo,aol)).

expose_term(email(N,Domain),"~a@~a.com",[N,Domain]).
+------------------------------------------+  

  Which when run will (usually) select the third clause:

+------------------------------------------+  
| ?- gen(say).
[RUGE INFO] "gen" invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
post(out,email(chico,hotmail)).
[RUGE INFO] Execution summary: 1 line in 0.0 seconds written to stdout
yes
+------------------------------------------+  

* Nested Rules

  Alternatively, the pct/2 constructs and generation rules might be separated. This leads to another reason
For using the <::> construct, that the generated term might be a variable that is bound lower-down in the program. 
This example produces the exact results as the previous one:

+------------------------------------------+  
say::R :- valid_say(R).

10 pct valid_say(message(hello,email(groucho,yahoo))).
10 pct valid_say(update(world,email(harpo,gmail))).
70 pct valid_say(post(out,email(chico,hotmail))).
10 pct valid_say(communique(there,email(zeppo,aol))).

expose_term(email(N,Domain),"~a@~a.com",[N,Domain]).
+------------------------------------------+  
  
* Parameter Passing

  Another reason for this syntax is to allow the passing of values that are not directly part of the generated term.
For example, another way to control the generated quantity is to pass the value into the rule:

+------------------------------------------+
say(N)::R :-
	between(1,N,_),
	valid_say(R).

valid_say(message(Word,email(User,Domain))) :-
	percent(Word,[hello,world,out,there,you]),
	percent(User,[groucho,harpo,chico,zeppo]),
	percent(Domain,[yahoo,gmail,hotmail,aol]).

expose_term(email(N,Domain),"~a@~a.com",[N,Domain]).
+------------------------------------------+  

  The value for N can be passed in like this:

+------------------------------------------+  
| ?- gen(say(3)).
[RUGE INFO] "gen" invoked from directory e:/dev/ruge/dcp/src/main/prolog/
message(hello,email(harpo,gmail)).
message(you,email(chico,aol)).
message(you,email(groucho,hotmail)).
[RUGE INFO] Execution summary: 3 lines in 0.001 seconds written to stdout
yes
+------------------------------------------+  

  It should be noted that -- useful for debugging -- you can still invoke these predicates directly 
from Prolog without going through RUGE:
  
+------------------------------------------+  
| ?- say(2)::R.
R = message(there,email(groucho,aol)) ? ;
R = message(out,email(zeppo,gmail)) ? ;
no
+------------------------------------------+    

* Buffering

  A final reason to use the '::' construct on rules is when buffering. RUGE output is not by default buffered, which makes for 
very fast output generation of large rulesets. Sometimes however it is desirable to buffer the data in memory to allow rules 
to reference previously-generated entries. The following program does this:


+------------------------------------------+    
:- dynamic message/2.

say::message(X,Count1) :-
	between(1,9,_),
	percent(X,[blue,green,red]),
	findall(X,message(X,_),Cs),
	length(Cs,Count),
	Count1 is Count+1.
+------------------------------------------+    

  Run without than with buffering, observe the effect:

+------------------------------------------+    
| ?- gen(say).
[RUGE INFO] "gen" invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
message(green,1).
message(green,1).
message(red,1).
message(blue,1).
message(blue,1).
message(blue,1).
message(blue,1).
message(red,1).
message(red,1).
[RUGE INFO] Execution summary: 9 lines in 0.003 seconds written to stdout
yes
| ?- buffer(gen(say)).
[RUGE INFO] "buffer" invoked from directory e:/dev/ruge/ruge/src/site/apt/prolog_samples/
message(blue,1).
message(red,1).
message(blue,2).
message(blue,3).
message(green,1).
message(red,2).
message(blue,4).
message(red,3).
message(red,4).
[RUGE INFO] Execution summary: 9 lines in 0.002 seconds written to stdout
yes
+------------------------------------------+    
  
  
Simulation and N-Stability

   TBD...




 
 